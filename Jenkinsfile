//----------------------------------------------------
// GLOBAL variables (used in different stages)
//----------------------------------------------------

/// for user configuration
def userConfig

/// for user response (approve/refuse after deployment - if deployment is not automatically tested)
def deployApprovedByUser

/// for ci/cd (internal)
def dockerImageFullUrl
def k8sNamespaceName
def k8sApplicationName

//----------------------------------------------------
// Pipeline
//----------------------------------------------------
podTemplate(
  containers: [
    // to build docker image and deploy it on registry
    containerTemplate(name: 'kaniko', image: 'gcr.io/kaniko-project/executor:debug', ttyEnabled: true, command: '/busybox/cat'),
    // to deploy application in the Kubernetes cluster
    containerTemplate(name: 'kubectl', image: 'lachlanevenson/k8s-kubectl', ttyEnabled: true, command: 'cat')
  ],
  volumes: [
    // this will create 2 files (due to Jenkins Credential integration) :
    //  - /tmp/.docker/filename ==> filename of the secret
    //  - /tmp/.docker/data     ==> data of the secret
    secretVolume(mountPath: '/tmp/.docker/', secretName: 'secret-file-kaniko-config')
  ])
{
  // POD_LABEL is the label of the pod running all the containers
  // the label is auto-generated by Jenkins and will automatically match
  // So Jenkins will wait until the pod turn to READY state <=> all containers are in a READY state
  node(POD_LABEL) {

    stage('Clean Workspace') {
      cleanWs()
    }

    stage('Checkout') {
      checkout scm
    }

    stage('Debug Environment') {
      sh 'env'
    }

    stage('Load user config (if exists)') {
      userConfig = readYaml file: 'cicd/config.yaml'
      if (userConfig != null) {
        echo 'User configuration has been loaded : ' + userConfig
      } else {
        echo 'User configuration not found ==> default value will be used'
      }
    }

    stage('Prepare variables') {

      // source code
      def sourceCodeRepositoryUrlAsList = scm.getUserRemoteConfigs()[0].getUrl().tokenize('/')
      def sourceCodeRepositoryUrlSize   = sourceCodeRepositoryUrlAsList.size()
      def sourceCodeRepositoryGroup     = sourceCodeRepositoryUrlAsList.get(sourceCodeRepositoryUrlSize - 2).split("\\.")[0]
      def sourceCodeRepositoryName      = sourceCodeRepositoryUrlAsList.last().split("\\.")[0]
      def checkoutScm                   = checkout(scm)
      def sourceCodeRepositoryBranch    = checkoutScm.GIT_BRANCH
      def sourceCodeRepositoryCommitId  = checkoutScm.GIT_COMMIT
      echo ("Source Code Repository Name   : " + sourceCodeRepositoryName)
      echo ("Source Code Repository Branch : " + sourceCodeRepositoryBranch)
      echo ("Source Code Repository Commit : " + sourceCodeRepositoryCommitId)

      // docker repository
      def dockerRegistryBaseUrl          = userConfig && userConfig.dockerRegistryBaseUrl         ? userConfig.dockerRegistryBaseUrl : 'REGISTRY_URL_FROM_OUR_STACK'
      def dockerRegistryImageRepository  = userConfig && userConfig.dockerRegistryImageRepository ? userConfig.dockerRegistryImageRepository : sourceCodeRepositoryGroup
      def dockerRegistryImageNameWithTag = sourceCodeRepositoryName + ":" + sourceCodeRepositoryCommitId
      dockerImageFullUrl                 = [dockerRegistryImageRepository, dockerRegistryImageNameWithTag].join('/')
      echo ("Docker Registry Image Repository : " + dockerRegistryImageRepository)
      echo ("Docker Registry Image Name       : " + dockerRegistryImageNameWithTag)
      echo ("Docker Registry Image Full URL   : " + dockerImageFullUrl)

      // Kubernetes labels
      k8sNamespaceName = sourceCodeRepositoryName + '-' + sourceCodeRepositoryBranch
      k8sApplicationName = sourceCodeRepositoryName
      echo ("Kubernetes Namespace Name: " + k8sNamespaceName)
      echo ("Kubernetes Application Name: " + k8sApplicationName)
    }

    stage('Docker Build/Push') {
        container('kaniko') {
            // recompose docker config for kaniko - must be /kaniko/.docker/config.json
            sh 'cat /tmp/.docker/data > /kaniko/.docker/$(cat /tmp/.docker/filename)'
            // build image and push it on registry
            sh '/kaniko/executor --context app --dockerfile app/Dockerfile --destination=' + dockerImageFullUrl
        }
    }

    stage('Display Merge-Request context (if exists)') {
      echo ("CHANGE_AUTHOR : "              + env.CHANGE_AUTHOR)
      echo ("CHANGE_AUTHOR_DISPLAY_NAME : " + env.CHANGE_AUTHOR_DISPLAY_NAME)
      echo ("CHANGE_BRANCH : "              + env.CHANGE_BRANCH)
      echo ("CHANGE_ID : "                  + env.CHANGE_ID)
      echo ("CHANGE_TARGET : "              + env.CHANGE_TARGET)
      echo ("CHANGE_TITLE : "               + env.CHANGE_TITLE)
      echo ("CHANGE_URL : "                 + env.CHANGE_URL)
      if (env.CHANGE_ID) {
        echo ("Context is a Merge-Request, continue to deployment stages...")
      } else {
        echo ("Context is NOT a Merge-Request, we stop here !")
      }
    }

    //----------------------------------------------------
    // from here, only if Merge-Request context
    // ==> deploy application for test
    //----------------------------------------------------
    if (env.CHANGE_ID) {

      stage('Prepare YAML') {

        // go to the folder containing user's application kubernetes ressources templates
        dir('app-deploy') {

          // create folder for target resources
          sh 'mkdir deploy'
          // service YAML
          sh 'cp service.yaml deploy/service.yaml'
          // deployment YAML
          container('kubectl') {
            sh 'kubectl set image -f deployment.yaml container-0=' + dockerImageFullUrl + ' --local -o yaml >> deploy/deployment.yaml'
          }
          // debug YAML files
          sh 'cat deploy/*.yaml'
        }
      }

      stage('Deploy to Kubernetes') {
        withKubeConfig([credentialsId: 'secret-file-kubeconfig']) {
          container('kubectl') {
            dir('app-deploy/deploy') {
              sh 'kubectl get pods'
              sh 'kubectl apply -f .'
              sh 'kubectl get deployments'
              sh 'kubectl get pods'
            }
          }
        }
      }

      stage('Test application') {
        deployApprovedByUser = input(
          id: 'successful',
          message: 'Your application has been deployed for test...',
          parameters: [
            [
              $class: 'BooleanParameterDefinition',
              defaultValue: 'false',
              description: 'Is it successful ?',
              name: 'successful'
            ]
          ]
        )
      }

      stage('Keep or Delete Kubernetes resources ?') {
        if (deployApprovedByUser) {
          withKubeConfig([credentialsId: 'secret-file-kubeconfig']) {
            container('kubectl') {
              dir('app-deploy/deploy') {
                sh 'kubectl delete -f .'
              }
            }
          }
          echo ("Application deployment has been approved")
          currentBuild.result = 'SUCCESS'
        } else {
          echo ("Application deplyment has not been approved")
          currentBuild.result = 'ERROR'
        }
      }

    }
  }
}

